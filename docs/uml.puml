@startuml
!pragma layout elk
skinparam linetype ortho
skinparam roundCorner 0
skinparam classAttributeIconSize 0
skinparam ClassBackgroundColor #OldLace
skinparam NoteBackgroundColor #OldLace
skinparam Shadowing false
top to bottom direction

<style>
    classDiagram {
        .provided {
            BackgroundColor GhostWhite
            LineColor DimGrey
            FontColor DimGrey
        }
    }
</style>

hide <<provided>> stereotype

interface ChessController<<provided>> {
    + start(view: ChessView): void
    + newGame(): void
    + move(fromX: int, fromY: int, toX: int, toY: int): boolean
}

interface UserChoice<<provided>> {
    + textValue(): String
}

' interface "DrawableResource<E>"<<provided>> {
'     + getResource(): E
' }

interface ChessView<<provided>> {
    + startView(): void
    + removePiece(x: int, y: int): void
    + putPiece(type: PieceType, color: PlayerColor, x: int, y: int): void
    + displayMessage(msg: String): void
}

' note left of ChessView
'     T implements User Choice: <T extends User Choice> in Java
' end note

' abstract class "BaseView<E>"<<provided>> implements ChessView {
'     + registerResource(type: PieceType, color: PlayerColor, res: DrawableResource<E>): void
'     # loadResourceFor(type: PieceType, color: PlayerColor, def: Resource): DrawableResource<E>
' }

' class GUIView<<provided>> extends "BaseView<E>" {
'     + startView(): void
'     + removePiece(x: int, y: int): void
'     + putPiece(x: int, y: int, type: PieceType, color: PlayerColor): void
' + displayMessage(msg: String): void
'     + askUser<T>(title: String, question: String, possibilities: ...T): T
' }

' class ConsoleView<<provided>> extends "BaseView<E>" {
'     + startView(): void
'     + removePiece(x: int, y: int): void
'     + putPiece(x: int, y: int, type: PieceType, color: PlayerColor): void
'     + displayMessage(msg: String): void
'     + askUser<T>(title: String, question: String, possibilities: ...T): T
' }

class ChessEngine implements ChessController {
    + start(view: ChessView): void
    + move(fromX: int, fromY: int, toX: int, toY: int): boolean
    + newGame(): void

    - makeMove(move: ChessMove): boolean
    - nextTurn(): void
    - oppositePlayer(): PlayerColor
}

interface ChessBoardView {
    + get(pos: Position): ChessPiece
    + containsKey(pos: Position): boolean
    + getLastMove(): ChessMove
    + isKingInCheck(kingColor: PlayerColor): boolean
    + isSquareAttacked(postition: Position, color: PlayerColor): boolean
    + isInAttackCalculationMode(): boolean
}

interface Cloneable<<provided>> {}

class ChessBoard implements ChessBoardView, Cloneable {
    - inAttackCalculationMode: boolean = false;

    + get(pos: Position): ChessPiece
    + containsKey(pos: Position): boolean
    + getLastMove(): ChessMove
    + setLastMove(chessMove: ChessMove): void
    + put(pos: Position, piece: ChessPiece): void
    + remove(pos: Position): void
    + clear(): void
    + sync(): void
    + getView(): ChessView
    + handlePawnPromotion(pos: Position, color: PlayerColor): void
    + isKingInCheck(kingColor: PlayerColor): boolean
    + isSquareAttacked(postition: Position, color: PlayerColor): boolean
    + isInAttackCalculationMode(): boolean
    + isCheckmate(color: PlayerColor): boolean
    + isStalemate(color: PlayerColor): boolean
    + clone(): ChessBoard

    - hasNoLegalMoves(color: PlayerColor): boolean
}

abstract class ChessBoardInitialzer {
    + {static} initializeBoard(board: ChessBoard): void

    - {static} placePawns(board: ChessBoard): void
    - {static} placeRooks(board: ChessBoard): void
    - {static} placeKnights(board: ChessBoard): void
    - {static} placeBishops(board: ChessBoard): void
    - {static} placeKings(board: ChessBoard): void
    - {static} placeQueens(board: ChessBoard): void
}

class Position {
    + {static} MAX_X: int = 7
    + {static} MAX_Y: int = 7

    + isValid(): boolean
    + dist(other: Position): int
    + add(other: Position): Position
    + sub(other: Position): Position
    + abs(): Position
    + toString(): String
}

enum PlayerColor<<provided>> {
    WHITE
    BLACK
}

enum PieceType<<provided>> {
    PAWN
    ROOK
    KNIGHT
    BISHOP
    QUEEN
    KING
}

abstract class ChessPiece implements Cloneable {
    - boolean: hasMoved

    + getType(): PieceType
    + getColor(): PlayerColor
    + isOpponent(other: ChessPiece): boolean
    + markMoved(): void
    + hasMoved(): boolean
    + getPossibleMoves(board: ChessBoardView, from: Position): Moves
    + clone(): ChessPiece
}
abstract class PromotableChessPiece extends ChessPiece implements UserChoice {
    + textValue(): String
}
class Pawn extends ChessPiece {
    + getPossibleMoves(board: ChessBoardView, from: Position): Moves

    - isValidMove(board: ChessBoardView, from: Position, to: Position): boolean
    - createAppropriateMove(from: Position, to: Position): ChessMove
    - createCaptureMove(from: Position, to: Position): ChessMove
    - createForwardMove(from: Position, to: Position): ChessMove
    - addEnPassantMoves(board: ChessBoardView, from: Position, moves: Moves): void
    - isValidEnPassantPosition(board: ChessBoardView, adjacent: Position): boolean
    - isDiagonalMove(from: Position, to: Position): boolean
    - isValidCapture(board: ChessBoardView, to: Position): boolean
    - isPawnAtPosition(board: ChessBoardView, pos: Position): boolean
    - wasDoublePawnAdvance(move: ChessMove): boolean
    - isAtPromotionRank(pos: Position): boolean
}
class Rook extends PromotableChessPiece {}
class Knight extends PromotableChessPiece {}
class Bishop extends PromotableChessPiece {}
class Queen extends PromotableChessPiece {}
class King extends ChessPiece {
    + getPossibleMoves(board: ChessBoardView, from: Position): Moves
    
    - getPossibleMoves(board: ChessBoardView, from: Position): Moves
    - getCastlingMoves(board: ChessBoardView, from: Position)
    - canCastle(board: ChessBoardView, from: Position, to: Position): boolean
    - getRookPosition(from: Position, direction: Direction): Position
    - isValidRook(rook: ChessPiece): boolean
    - areSquaresBetweenEmptyAndSafe(board: ChessBoardView, from: Position, rookPos: Position): boolean
    - isRookPositionSafe(board: ChessBoardView, rookPos: Position): boolean
}


abstract class MoveGenerator implements Cloneable {
    + {abstract} generate(board: ChessBoardView, from: Position): Moves
    + clone(): MoveGenerator
}
class DirectionalGenerator extends MoveGenerator {
    + generate(board: ChessBoardView, from: Position): Moves
}
class KnightGenerator extends MoveGenerator {
    - {static} KNIGHT_MOVES: int[][]

    + generate(board: ChessBoardView, from: Position): Moves
}
class DistanceGenerator extends MoveGenerator {
    - maxDistance: int

    + getMaxDistance(): int
    + setMaxDistance(maxDistance: int): void
    + generate(board: ChessBoardView, from: Position): Moves
    + clone(): DistanceGenerator
}
class PawnDistanceGenerator extends DistanceGenerator {
    + generate(board: ChessBoardView, from: Position): Moves
}

enum Direction {
    FORWARDS
    BACKWARDS
    LEFT
    RIGHT
    FORWARDS_LEFT
    FORWARDS_RIGHT
    BACKWARDS_LEFT
    BACKWARDS_RIGHT

    + {static} ALL: List<Direction>
    + {static} STRAIGHT: List<Direction>
    + {static} DIAGONAL: List<Direction>

    + add(position: Position): Position
    + toString(): String

    - getDx(color: PlayerColor): int
    - getDy(color: PlayerColor): int
}


class Moves {
    + addMove(move: ChessMove): void
    + extendMoves(moves: Moves): void
    + getMove(position: Position): ChessMove
    + getAllMoves(): Collection<ChessMove>
    + toString(): String
}

abstract class ChessMove {
    + getTo(): Position
    + {abstract} execute(board: ChessBoard): void
    + toString(): String
}

class StandardMove extends ChessMove {
    + execute(board: ChessBoard): void
}
class Capture extends ChessMove {
    + execute(board: ChessBoard): void
}
class EnPassant extends StandardMove {
    + execute(board: ChessBoard): void
}
abstract class Castling extends ChessMove {
    + execute(board: ChessBoard): void

    # {abstract} getRookInitialPosition(): Position
    # {abstract} getRookFinalPosition(): Position
}
class LongCastling extends Castling {
    - {static} QUEEN_SIDE_ROOK_INITIAL_X: int = 0;
    - {static} QUEEN_SIDE_ROOK_FINAL_X: int = 3;

    # getRookInitialPosition(): Position
    # getRookFinalPosition(): Position
}
class ShortCastling extends Castling {
    - {static} KING_SIDE_ROOK_INITIAL_X: int = Position.MAX_X;
    - {static} KING_SIDE_ROOK_FINAL_X: int = 5;

    # getRookInitialPosition(): Position
    # getRookFinalPosition(): Position
}
class Promotion extends StandardMove {
    + execute(board: ChessBoard): void
}
class PromotionWithCapture extends Capture {
    + execute(board: ChessBoard): void
}

ChessController "1" --> "1" ChessView : manage >

ChessEngine "1" --> "1" ChessBoard : manages >
ChessEngine "1" --> "1" PlayerColor : hasTurn >
ChessEngine --> ChessBoardInitialzer : usesStatically >
ChessBoard "1" --> "1" ChessView : has >
ChessBoard "1" *-- "2..32" ChessPiece : composedOf
ChessBoard "1" *-- "2" Position : tracks >
ChessPiece "1" --> "1" PieceType : represents >
ChessPiece "1" --> "1" PlayerColor : belongsTo >
ChessPiece "1" *-- "1..*" MoveGenerator : composedOf >

DirectionalGenerator "1" *-- "1..*" Direction : defines >
DistanceGenerator "1" *-- "1..*" DirectionalGenerator : uses >

ChessMove "1" --> "1" Position : startsAt >
ChessMove "1" --> "1" Position : endsAt >
Moves "1" *-- "*" ChessMove : includes >
EnPassant "1" --> "1" Position : captures >

@enduml
